package dbtypegen

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"io"
	"strings"

	"github.com/iancoleman/strcase"
	"github.com/k0kubun/sqldef/sqlparser"
	"golang.org/x/tools/imports"
)

// Option is option for generator.
type Option func(*config)

type config struct {
	pkg        string
	jsonType   string
	uuidType   string
	typeSuffix string
	typePrefix string
	tag        string
}

// WithPackage returns an option that sets package name.
func WithPackage(pkg string) Option {
	return func(cfg *config) {
		cfg.pkg = pkg
	}
}

// WithJSONType returns an option that sets json type.
func WithJSONType(jsonType string) Option {
	return func(cfg *config) {
		cfg.jsonType = jsonType
	}
}

// WithUUIDType returns an option that sets uuid type.
func WithUUIDType(uuidType string) Option {
	return func(cfg *config) {
		cfg.uuidType = uuidType
	}
}

// WithTypePrefix returns an option that sets type prefix.
func WithTypePrefix(typePrefix string) Option {
	return func(cfg *config) {
		cfg.typePrefix = typePrefix
	}
}

// WithTypeSuffix returns an option that sets type suffix.
func WithTypeSuffix(typeSuffix string) Option {
	return func(cfg *config) {
		cfg.typeSuffix = typeSuffix
	}
}

// WithTag returns an option that sets struct tag.
func WithTag(tag string) Option {
	return func(cfg *config) {
		cfg.tag = tag
	}
}

func defaults() []Option {
	return []Option{
		WithPackage("dbtype"),
		WithJSONType("json.RawMessage"),
		WithUUIDType("string"),
		WithTypePrefix(""),
		WithTypeSuffix(""),
		WithTag("db"),
	}
}

type generator struct {
	*config
}

// Generate generates go source code and returns the data.
func Generate(ctx context.Context, r io.Reader, opts ...Option) ([]byte, error) {
	cfg := new(config)
	opts = append(defaults(), opts...)
	for _, opt := range opts {
		opt(cfg)
	}

	g := &generator{config: cfg}

	b := new(bytes.Buffer)
	fp(b, "// Code generated by dbtypegen. DO NOT EDIT.")
	fp(b, "\n")
	fp(b, "package %s", g.pkg)

	tokens := sqlparser.NewTokenizer(r)
	for {
		select {
		case <-ctx.Done():
			return nil, ctx.Err()
		default:
		}
		stmt, err := sqlparser.ParseNext(tokens)
		if err != nil {
			if errors.Is(err, io.EOF) {
				break
			}
			return nil, err
		}

		ddl, ok := stmt.(*sqlparser.DDL)
		if !ok {
			continue
		}
		if ddl.Action == "create" {
			if err := g.generate(b, ddl); err != nil {
				return nil, err
			}
		}
	}

	out, err := imports.Process("", b.Bytes(), nil)
	if err != nil {
		return nil, err
	}

	return out, nil
}

func (g *generator) generate(w io.Writer, ddl *sqlparser.DDL) error {
	tableName := ddl.NewName.Name.String()
	structName := g.typePrefix + toCamel(tableName) + g.typeSuffix

	fp(w, "// %s is the type that represents table `%s`.", structName, tableName)
	fp(w, "type %s struct {", structName)

	if ddl.TableSpec == nil {
		return nil
	}
	columns := make([]string, 0, len(ddl.TableSpec.Columns))
	fields := make([]string, 0, len(ddl.TableSpec.Columns))
	for _, c := range ddl.TableSpec.Columns {
		var length int
		if c.Type.Length != nil {
			length = int(c.Type.Length.Type)
		}
		var typ string
		switch strings.ToLower(c.Type.Type) {
		case "varchar", "char", "text":
			typ = "string"
		case "int", "integer", "decimal", "numeric", "number", "smallint", "real":
			typ = "int"
		case "bigint", "timestamp":
			typ = "int64"
		case "tinyint":
			if length == 1 {
				typ = "bool"
			} else {
				typ = "int"
			}
		case "float", "double":
			typ = "float64"
		case "datetime", "date", "time", "year":
			typ = "time.Time"
		case "bool", "boolean":
			typ = "bool"
		case "json":
			typ = g.jsonType
		case "blob":
			typ = "[]byte"
		case "bit":
			typ = "uint32"
		case "uuid":
			typ = g.uuidType
		default:
			return fmt.Errorf("unsupported type %s", c.Type.Type)
		}
		if c.Type.NotNull != nil && !*c.Type.NotNull {
			typ = fmt.Sprintf("sql.Null%s", toCamel(typ))
		}
		columnName := c.Name.String()
		fieldName := toCamel(columnName)
		columns = append(columns, columnName)
		fields = append(fields, fieldName)
		fp(w, "%s %s `%s:\"%s\"`", fieldName, typ, g.tag, c.Name)
	}
	fp(w, "}")

	fp(w, "\n")

	columnsString := strings.Join(columns, ",")
	fp(w, "// Columns returns all columns as joined string")
	fp(w, "func (t *%s) Columns() string {", structName)
	fp(w, "return \"%s\"", columnsString)
	fp(w, "}")

	fp(w, "\n")

	fp(w, "// ColumnList returns all columns as slice of string.")
	fp(w, "func (t *%s) ColumnList() []string {", structName)
	fp(w, "return []string{\"%s\"}", strings.Join(columns, "\",\""))
	fp(w, "}")

	fp(w, "\n")

	fp(w, "// TableName returns the name of table.")
	fp(w, "func (t *%s) TableName() string {", structName)
	fp(w, "return \"%s\"", tableName)
	fp(w, "}")

	fp(w, "\n")

	fp(w, "// SelectAll returns a part of query like `SELECT id,name FROM people`.")
	fp(w, "func (t *%s) SelectAll() string {", structName)
	fp(w, "return \"SELECT %s FROM %s\"", columnsString, tableName)
	fp(w, "}")

	fp(w, "\n")

	fp(w, "// ScanAll returns field's pointers for row.Scan.")
	fp(w, "func (t *%s) ScanAll() []interface{} {", structName)
	fp(w, "return []interface{}{&t.%s}", strings.Join(fields, ",&t."))
	fp(w, "}")

	fp(w, "\n")
	return nil
}

func fp(w io.Writer, format string, args ...interface{}) {
	fmt.Fprintf(w, "\n"+format, args...)
}

func toCamel(s string) string {
	return strcase.ToCamel(s)
}
